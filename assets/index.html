<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tanks</title>
    <script src="lib/phaser.min.js"></script>
    <script src="js/test-scene.js"></script>
</head>
<body>
<script>
    let ws = new WebSocket('ws://195.133.196.73:8080/state/');
    const config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        backgroundColor: '#bbbbbb',
        scene: [TestScene],
        title: 'Tanks',
        version: '0.01',
    };
    const gameState = {};

    ws.onopen = function(evt) {
        console.log("open");
        const game = new Phaser.Game(config);
        initState();
    }

    ws.onclose = function(evt) {
        console.log("CLOSE");
        ws = null;
    }
    ws.onmessage = function(evt) {
        processGameUpdate(evt.data);
    }
    ws.onerror = function(evt) {
        console.log(evt);
    }

    const RENDER_DELAY = 100;

    const gameUpdates = [];
    let gameStart = 0;
    let firstServerTimestamp = 0;

    function initState() {
        gameStart = 0;
        firstServerTimestamp = 0;
    }

    function processGameUpdate(update) {
        update = JSON.parse(update);

        if (!firstServerTimestamp) {
            firstServerTimestamp = update.t;
            gameStart = Date.now();
        }
        gameUpdates.push(update);

        // Keep only one game update before the current server time
        const base = getBaseUpdate();
        if (base > 0) {
            gameUpdates.splice(0, base);
        }
    }

    function currentServerTime() {
        return firstServerTimestamp + (Date.now() - gameStart) - RENDER_DELAY;
    }

    function getBaseUpdate() {
        const serverTime = currentServerTime();
        for (let i = gameUpdates.length - 1; i >= 0; i--) {
            if (gameUpdates[i].t <= serverTime) {
                return i;
            }
        }
        return -1;
    }

    function getCurrentState() {
        if (!firstServerTimestamp) {
            return {};
        }

        const base = getBaseUpdate();
        const serverTime = currentServerTime();

        // If base is the most recent update we have, use its state.
        // Otherwise, interpolate between its state and the state of (base + 1).
        if (base < 0 || base === gameUpdates.length - 1) {
            return gameUpdates[gameUpdates.length - 1];
        } else {
            const baseUpdate = gameUpdates[base];
            const next = gameUpdates[base + 1];
            const ratio = (serverTime - baseUpdate.t) / (next.t - baseUpdate.t);
            return {
                players: interpolateObjectArray(baseUpdate.players, next.players, ratio)
            }
        }
    }

    function interpolateObject(object1, object2, ratio) {
        if (!object2) {
            return object1;
        }

        const interpolated = {};
        Object.keys(object1).forEach(key => {
            interpolated[key] = object1[key] + (object2[key] - object1[key]) * ratio;
        });
        return interpolated;
    }

    function interpolateObjectArray(objects1, objects2, ratio) {
        return objects1.map((o, i) => interpolateObject(o, objects2[i], ratio));
        // У наших объектов нет поля id
        // return objects1.map(o => interpolateObject(o, objects2.find(o2 => o.id === o2.id), ratio));
    }
</script>
</body>
</html>

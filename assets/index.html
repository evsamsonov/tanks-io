<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Test</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            overscroll-behavior: none;
            background-color: black;
        }
    </style>
</head>
<body>
<canvas id="game-canvas"></canvas>
<script>
    (function() {
        // Get the canvas graphics context
        const canvas = document.getElementById('game-canvas');
        const context = canvas.getContext('2d');
        setCanvasDimensions();

        function setCanvasDimensions() {
            // On small screens (e.g. phones), we want to "zoom out" so players can still see at least
            // 800 in-game units of width.
            const scaleRatio = Math.max(1, 800 / window.innerWidth);
            canvas.width = scaleRatio * window.innerWidth;
            canvas.height = scaleRatio * window.innerHeight;
        }

        window.addEventListener('resize', debounce(40, setCanvasDimensions));

        function render() {
            const state = getCurrentState();

            state.players.forEach(function(i) {
                renderPlayer(i);
            });
        }

        let ws = new WebSocket("ws://localhost:8080/state/");
        ws.onopen = function(evt) {
            console.log("OPEN");
            initState();
            startRendering();
        }
        ws.onclose = function(evt) {
            console.log("CLOSE");
            ws = null;
        }
        ws.onmessage = function(evt) {
            processGameUpdate(evt.data);
        }
        ws.onerror = function(evt) {
            console.log("ERROR: " + evt.data);
        }

        const RENDER_DELAY = 100;

        const gameUpdates = [];
        let gameStart = 0;
        let firstServerTimestamp = 0;

        function initState() {
            gameStart = 0;
            firstServerTimestamp = 0;
        }

        function processGameUpdate(update) {
            update = JSON.parse(update);

            if (!firstServerTimestamp) {
                firstServerTimestamp = update.t;
                gameStart = Date.now();
            }
            gameUpdates.push(update);

            // Keep only one game update before the current server time
            const base = getBaseUpdate();
            if (base > 0) {
                gameUpdates.splice(0, base);
            }
        }

        function currentServerTime() {
            return firstServerTimestamp + (Date.now() - gameStart) - RENDER_DELAY;
        }

        // Returns the index of the base update, the first game update before
        // current server time, or -1 if N/A.
        function getBaseUpdate() {
            const serverTime = currentServerTime();
            for (let i = gameUpdates.length - 1; i >= 0; i--) {
                if (gameUpdates[i].t <= serverTime) {
                    return i;
                }
            }
            return -1;
        }

        // Returns { me, others, bullets }
        function getCurrentState() {
            if (!firstServerTimestamp) {
                return {};
            }

            const base = getBaseUpdate();
            const serverTime = currentServerTime();

            // If base is the most recent update we have, use its state.
            // Otherwise, interpolate between its state and the state of (base + 1).
            if (base < 0 || base === gameUpdates.length - 1) {
                return gameUpdates[gameUpdates.length - 1];
            } else {
                const baseUpdate = gameUpdates[base];
                const next = gameUpdates[base + 1];
                const ratio = (serverTime - baseUpdate.t) / (next.t - baseUpdate.t);
                return {
                    players: interpolateObjectArray(baseUpdate.players, next.players, ratio)
                }
            }
        }

        // Renders a ship at the given coordinates
        function renderPlayer(player) {
            context.fillStyle = 'red';
            context.fillRect(
                player.x,
                player.y,
                10,
                10,
            );
        }

        // Replaces main menu rendering with game rendering.
        function startRendering() {
            setInterval(render, 1000 / 60);
        }
        function interpolateObject(object1, object2, ratio) {
            if (!object2) {
                return object1;
            }

            const interpolated = {};
            Object.keys(object1).forEach(key => {
                interpolated[key] = object1[key] + (object2[key] - object1[key]) * ratio;
            });
            return interpolated;
        }
        function interpolateObjectArray(objects1, objects2, ratio) {
            return objects1.map((o, i) => interpolateObject(o, objects2[i], ratio));
            // У наших объектов нет поля id
            // return objects1.map(o => interpolateObject(o, objects2.find(o2 => o.id === o2.id), ratio));
        }
        function throttle (delay, noTrailing, callback, debounceMode) {
            /*
             * After wrapper has stopped being called, this timeout ensures that
             * `callback` is executed at the proper times in `throttle` and `end`
             * debounce modes.
             */
            var timeoutID;
            var cancelled = false; // Keep track of the last time `callback` was executed.

            var lastExec = 0; // Function to clear existing timeout

            function clearExistingTimeout() {
                if (timeoutID) {
                    clearTimeout(timeoutID);
                }
            } // Function to cancel next exec


            function cancel() {
                clearExistingTimeout();
                cancelled = true;
            } // `noTrailing` defaults to falsy.


            if (typeof noTrailing !== 'boolean') {
                debounceMode = callback;
                callback = noTrailing;
                noTrailing = undefined;
            }
            /*
             * The `wrapper` function encapsulates all of the throttling / debouncing
             * functionality and when executed will limit the rate at which `callback`
             * is executed.
             */


            function wrapper() {
                var self = this;
                var elapsed = Date.now() - lastExec;
                var args = arguments;

                if (cancelled) {
                    return;
                } // Execute `callback` and update the `lastExec` timestamp.


                function exec() {
                    lastExec = Date.now();
                    callback.apply(self, args);
                }
                /*
                 * If `debounceMode` is true (at begin) this is used to clear the flag
                 * to allow future `callback` executions.
                 */


                function clear() {
                    timeoutID = undefined;
                }

                if (debounceMode && !timeoutID) {
                    /*
                     * Since `wrapper` is being called for the first time and
                     * `debounceMode` is true (at begin), execute `callback`.
                     */
                    exec();
                }

                clearExistingTimeout();

                if (debounceMode === undefined && elapsed > delay) {
                    /*
                     * In throttle mode, if `delay` time has been exceeded, execute
                     * `callback`.
                     */
                    exec();
                } else if (noTrailing !== true) {
                    /*
                     * In trailing throttle mode, since `delay` time has not been
                     * exceeded, schedule `callback` to execute `delay` ms after most
                     * recent execution.
                     *
                     * If `debounceMode` is true (at begin), schedule `clear` to execute
                     * after `delay` ms.
                     *
                     * If `debounceMode` is false (at end), schedule `callback` to
                     * execute after `delay` ms.
                     */
                    timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
                }
            }

            wrapper.cancel = cancel; // Return the wrapper function.

            return wrapper;
        }
        function debounce (delay, atBegin, callback) {
            return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
        }
    }) ();
</script>
</body>
</html>
